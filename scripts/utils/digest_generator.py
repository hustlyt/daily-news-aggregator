from typing import List, Dict
from datetime import datetime
import pytz
import os
import glob


class DigestGenerator:
    """日报生成器"""

    def __init__(self, timezone: str = "Asia/Shanghai", config: Dict = None):
        self.timezone = pytz.timezone(timezone)
        self.config = config or {}

    def generate_daily_digest(self, sources_data: Dict[str, Dict], output_path: str) -> bool:
        """生成每日汇总文档"""
        try:
            # 获取当前时间
            now = datetime.now(self.timezone)
            date_str = now.strftime('%Y-%m-%d')
            time_str = now.strftime('%Y-%m-%d %H:%M:%S')

            # 统计总的新增项目数
            total_new_items = sum(len(data['new_articles']) for data in sources_data.values())

            if total_new_items == 0:
                print("今日没有新增内容")
                return False

            # 生成Markdown内容
            markdown_content = self._generate_markdown(sources_data, date_str, time_str, total_new_items)

            # 确保输出目录存在
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            # 写入文件
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(markdown_content)

            print(f"每日汇总已生成: {output_path}")
            print(f"包含 {len(sources_data)} 个数据源，{total_new_items} 个新增项目")

            # 清理旧文件
            self._cleanup_old_files(output_path)

            return True

        except Exception as e:
            print(f"生成每日汇总失败: {e}")
            return False

    def _generate_markdown(self, sources_data: Dict, date_str: str, time_str: str, total_items: int) -> str:
        """生成Markdown内容"""
        lines = [
            f"# 每日发现汇总 - {date_str}",
            "",
            f"> 本文档汇总了今日各大推荐网站的新增内容",
            ""
        ]

        # 为每个数据源添加内容
        for source_name, data in sources_data.items():
            config = data['config']
            new_articles = data['new_articles']

            if not new_articles:
                continue

            lines.extend([
                f"## {config['icon']} {config['display_name']} ({source_name})",
                ""
            ])

            # 添加每个新增项目
            for article in new_articles:
                if isinstance(article, dict):
                    # 处理字典格式的推荐项目
                    markdown_item = self._dict_to_markdown(article)
                    lines.append(markdown_item)
                else:
                    # 处理有to_markdown方法的对象
                    lines.append(article.to_markdown())

            lines.append("")

        # 添加页脚信息
        lines.extend([
            "---",
            "",
            f"**更新时间**: {time_str}  ",
            f"**数据源**: {len([s for s in sources_data.values() if s['new_articles']])} 个网站  ",
            f"**新增项目**: {total_items} 个  ",
            "",
            "<!-- Generated by Daily News Aggregator -->"
        ])

        return "\n".join(lines)

    def _dict_to_markdown(self, article: Dict) -> str:
        """将字典格式的推荐项目转换为Markdown格式"""
        title = article.get('title', '未知标题')
        url = article.get('url', '')
        description = article.get('description', '')

        # 构建markdown格式
        markdown_parts = []

        # 标题和链接
        if url:
            markdown_parts.append(f"**[{title}]({url})**")
        else:
            markdown_parts.append(f"**{title}**")

        # 描述
        if description:
            markdown_parts.append(f"  \n{description}")

        # 其他信息（如果需要的话可以在这里添加）
        # 暂时不添加任何额外信息，保持简洁

        return "\n".join(markdown_parts) + "\n"

    def _cleanup_old_files(self, current_file_path: str):
        """清理旧的Markdown文件，保持文件数量限制"""
        try:
            # 从配置中获取最大文件数，默认30
            max_files = self.config.get('output_config', {}).get('max_files', 30)

            # 获取文件所在目录
            output_dir = os.path.dirname(current_file_path)

            # 查找所有.md文件
            md_files = glob.glob(os.path.join(output_dir, "*.md"))

            # 按修改时间排序，最新的在前
            md_files.sort(key=lambda x: os.path.getmtime(x), reverse=True)

            # 如果文件数量超过限制，删除多余的
            if len(md_files) > max_files:
                files_to_delete = md_files[max_files:]
                for file_path in files_to_delete:
                    try:
                        os.remove(file_path)
                        print(f"🗑️  删除旧文件: {os.path.basename(file_path)}")
                    except Exception as e:
                        print(f"删除文件失败 {file_path}: {e}")

                print(f"📝 保留最新的 {max_files} 个文件，删除了 {len(files_to_delete)} 个旧文件")
            else:
                print(f"📝 当前有 {len(md_files)} 个文件，未超过限制 {max_files}")

        except Exception as e:
            print(f"清理旧文件时出错: {e}")

    def get_output_filename(self, base_dir: str) -> str:
        """获取输出文件名"""
        now = datetime.now(self.timezone)
        date_str = now.strftime('%Y-%m-%d')
        return os.path.join(base_dir, f"daily-digest-{date_str}.md")